{
    "docs": [
        {
            "location": "/",
            "text": "ModelerToolbox.jl docs\n\u00b6\n\n\nWelcome to the docs, I'll try to keep this simple.\n\n\n\n\nModelerToolbox.jl docs\n\n\nJLD tools",
            "title": "Home"
        },
        {
            "location": "/#modelertoolboxjl-docs",
            "text": "Welcome to the docs, I'll try to keep this simple.   ModelerToolbox.jl docs  JLD tools",
            "title": "ModelerToolbox.jl docs"
        },
        {
            "location": "/jld/",
            "text": "JLD tools\n\u00b6\n\n\nI often find myself working with many different parameterizations of a given model. I often need to store things like initial guesses, solutions, etc. so I can come back to the model and pick up right where I left off. In the past this has involved one of two things:\n\n\n\n\nSome ad hoc file naming system I use to identify which version of which model a particular object belongs to\n\n\nA variation of the same where I at least collect objects for the same model in a dedicated folder\n\n\n\n\nThe main problem with this approach is that when I'm doing research, I don't usually know all the permutations of parameters and models that I'll need. This makes it very difficult to support this type of ad hoc system as the project expands. What I really needed was something that scales with the project.\n\n\nModelerToolbox defines a set of routines that makes scalable, per model data storage easy. The routines are built on top of JLD.jl, which in turn uses HDF5.jl for storage.\n\n\nThe user of this package will need to implement their own methods for two key functions exported by ModelerToolbox:\n\n\n\n\njld_fn(::T)\n: gives the full path to the jld file that should be used when storing data for objects of type \nT\n\n\ngroup_keys(::T)\n: gives a unique key that allows you to distinguish one instance of type \nT\n from another.\n\n\n\n\nOnce these two methods have been defined for your type \nT\n, ModelerToolbox provides the following methods (see docstrings for details on what each of them does):\n\n\n#\n\n\nModelerToolbox.init_jld\n \u2014 \nMethod\n.\n\n\ninit_jld\n(\nx\n,\n \n[\nforce\n=\nfalse\n])\n\n\n\n\n\n\nInitialize the jld_file for objects of type \ntypeof(x)\n. This creates the file (if needed) and ensures that a \ngroups\n dataset exists and constructs a group for the instance \nx\n.\n\n\nIf \nforce\n is \ntrue\n any existing file is overwritten and the above operations are performed.\n\n\nThis should only be called by users when they want to completely reconstruct the jld file.\n\n\n#\n\n\nModelerToolbox.groupname\n \u2014 \nMethod\n.\n\n\ngroupname\n(\nx\n::\nT\n)\n\n\n\n\n\n\nReturns a tuple \n(name, group_map_exists, group_exists)\n specifying the \nname\n of the group for x, whether a map from \ngroup_keys(x)\n to a group name exists in the jld file, and whether or not a group with \nname\n exists in the jld file. Mostly an internal function\n\n\n#\n\n\nModelerToolbox.groupname!\n \u2014 \nMethod\n.\n\n\ngroupname!\n(\nx\n::\nT\n)\n\n\n\n\n\n\nReturns the same as \ngroupname(x)\n, but also creates the group map (if \ngroup_map_exists == false\n) and the group (if \ngroup_exists == false\n).\n\n\n#\n\n\nModelerToolbox.delete_group!\n \u2014 \nMethod\n.\n\n\ndelete_group!\n(\nx\n)\n\n\n\n\n\n\nDelete the jld group associated with the instance of \nx\n and remove its entry from the group map.\n\n\n#\n\n\nModelerToolbox.with_group\n \u2014 \nMethod\n.\n\n\nwith_group\n(\nfunc!\n::\nFunction\n,\n \nx\n)\n\n\n\n\n\n\nWith the jld group corresponding to the instance \nx\n as \ng\n, call \nfunc!(g)\n. This is a core method that is used to interact with the group for an object.\n\n\n#\n\n\nModelerToolbox.@with_group\n \u2014 \nMacro\n.\n\n\nmacro\n \nwith_group\n(\nfunc\n)\n\n\n\n\n\n\nWrap the body of a function \nfunc\n in a call to \nwith_group\n. This is best understood by example.\n\n\n@\nwith_group\n \nwrite_jld\n(\nx\n,\n \nnm\n,\n \nobj\n)\n \n=\n \nwrite\n(\ng\n,\n \nnm\n,\n \nobj\n)\n\n\n\n\n\n\nis equivalent to\n\n\nwrite_jld\n(\nx\n,\n \nnm\n,\n \nobj\n)\n \n=\n \nwith_group\n(\ng\n \n->\n \nwrite\n(\ng\n,\n \nnm\n,\n \nobj\n),\n \nx\n)\n\n\n\n\n\n\n#\n\n\nModelerToolbox.with_file\n \u2014 \nMethod\n.\n\n\nwith_file\n(\nfunc!\n::\nFunction\n,\n \nx\n)\n\n\n\n\n\n\nWith the jld file object for objects of type \ntypeof(x)\n as \nf\n, call \nfunc!(f)\n. This is a core method that is used to interact with the jld file as a whole.\n\n\n#\n\n\nModelerToolbox.@with_file\n \u2014 \nMacro\n.\n\n\nmacro\n \nwith_group\n(\nfunc\n)\n\n\n\n\n\n\nWrap the body of a function \nfunc\n in a call to \nwith_file\n. This is best understood by example.\n\n\n@\nwith_file\n \nfoobar\n(\nx\n,\n \ny\n)\n \n=\n \nfoobar\n(\nf\n,\n \ny\n)\n\n\n\n\n\n\nis equivalent to\n\n\nfoobar\n(\nx\n,\n \nnm\n,\n \nobj\n)\n \n=\n \nwith_file\n(\nf\n \n->\n \nfoobar\n(\ny\n),\n \nx\n)\n\n\n\n\n\n\n#\n\n\nModelerToolbox.write_jld\n \u2014 \nMethod\n.\n\n\nwrite_jld\n(\nx\n,\n \nnm\n,\n \nobj\n)\n\n\n\n\n\n\nWrite the object \nobj\n \nx\n's jld group under name \nnm\n\n\n#\n\n\nModelerToolbox.write_jld!\n \u2014 \nMethod\n.\n\n\nwrite_jld!\n(\nx\n,\n \nnm\n,\n \nobj\n)\n\n\n\n\n\n\nWrite the object \nobj\n \nx\n's jld group under name \nnm\n. This routine will overwrite any existing object with name \nnm\n in the group.\n\n\n#\n\n\nModelerToolbox.read_jld\n \u2014 \nMethod\n.\n\n\nread_jld\n(\nx\n,\n \nnm\n)\n\n\n\n\n\n\nRead the object with \nnm\n from  \nx\n's jld group\n\n\n#\n\n\nModelerToolbox.delete_jld!\n \u2014 \nMethod\n.\n\n\ndelete_jld!\n(\nx\n,\n \ndataset\n)\n\n\n\n\n\n\nDelete the object with name \ndataset\n from \nx\n's jld group\n\n\n#\n\n\nModelerToolbox.haskey_jld\n \u2014 \nMethod\n.\n\n\nhaskey_jld\n(\nx\n,\n \ndataset\n)\n\n\n\n\n\n\nCheck if the jld group for \nx\n has an object named \ndataset\n\n\n#\n\n\nModelerToolbox.names_jld\n \u2014 \nMethod\n.\n\n\nnames_jld\n(\nx\n)\n\n\n\n\n\n\nList all the names in \nx\n's jld group\n\n\n#\n\n\nModelerToolbox.groups\n \u2014 \nMethod\n.\n\n\ngroups\n(\nx\n)\n\n\n\n\n\n\nReturn the dict mapping keys to jld group names for all objects of type \ntypeof(x)\n. If the dict doesn't yet exist, it is created, along with a group for the instance \nx\n.",
            "title": "JLD"
        },
        {
            "location": "/jld/#jld-tools",
            "text": "I often find myself working with many different parameterizations of a given model. I often need to store things like initial guesses, solutions, etc. so I can come back to the model and pick up right where I left off. In the past this has involved one of two things:   Some ad hoc file naming system I use to identify which version of which model a particular object belongs to  A variation of the same where I at least collect objects for the same model in a dedicated folder   The main problem with this approach is that when I'm doing research, I don't usually know all the permutations of parameters and models that I'll need. This makes it very difficult to support this type of ad hoc system as the project expands. What I really needed was something that scales with the project.  ModelerToolbox defines a set of routines that makes scalable, per model data storage easy. The routines are built on top of JLD.jl, which in turn uses HDF5.jl for storage.  The user of this package will need to implement their own methods for two key functions exported by ModelerToolbox:   jld_fn(::T) : gives the full path to the jld file that should be used when storing data for objects of type  T  group_keys(::T) : gives a unique key that allows you to distinguish one instance of type  T  from another.   Once these two methods have been defined for your type  T , ModelerToolbox provides the following methods (see docstrings for details on what each of them does):  #  ModelerToolbox.init_jld  \u2014  Method .  init_jld ( x ,   [ force = false ])   Initialize the jld_file for objects of type  typeof(x) . This creates the file (if needed) and ensures that a  groups  dataset exists and constructs a group for the instance  x .  If  force  is  true  any existing file is overwritten and the above operations are performed.  This should only be called by users when they want to completely reconstruct the jld file.  #  ModelerToolbox.groupname  \u2014  Method .  groupname ( x :: T )   Returns a tuple  (name, group_map_exists, group_exists)  specifying the  name  of the group for x, whether a map from  group_keys(x)  to a group name exists in the jld file, and whether or not a group with  name  exists in the jld file. Mostly an internal function  #  ModelerToolbox.groupname!  \u2014  Method .  groupname! ( x :: T )   Returns the same as  groupname(x) , but also creates the group map (if  group_map_exists == false ) and the group (if  group_exists == false ).  #  ModelerToolbox.delete_group!  \u2014  Method .  delete_group! ( x )   Delete the jld group associated with the instance of  x  and remove its entry from the group map.  #  ModelerToolbox.with_group  \u2014  Method .  with_group ( func! :: Function ,   x )   With the jld group corresponding to the instance  x  as  g , call  func!(g) . This is a core method that is used to interact with the group for an object.  #  ModelerToolbox.@with_group  \u2014  Macro .  macro   with_group ( func )   Wrap the body of a function  func  in a call to  with_group . This is best understood by example.  @ with_group   write_jld ( x ,   nm ,   obj )   =   write ( g ,   nm ,   obj )   is equivalent to  write_jld ( x ,   nm ,   obj )   =   with_group ( g   ->   write ( g ,   nm ,   obj ),   x )   #  ModelerToolbox.with_file  \u2014  Method .  with_file ( func! :: Function ,   x )   With the jld file object for objects of type  typeof(x)  as  f , call  func!(f) . This is a core method that is used to interact with the jld file as a whole.  #  ModelerToolbox.@with_file  \u2014  Macro .  macro   with_group ( func )   Wrap the body of a function  func  in a call to  with_file . This is best understood by example.  @ with_file   foobar ( x ,   y )   =   foobar ( f ,   y )   is equivalent to  foobar ( x ,   nm ,   obj )   =   with_file ( f   ->   foobar ( y ),   x )   #  ModelerToolbox.write_jld  \u2014  Method .  write_jld ( x ,   nm ,   obj )   Write the object  obj   x 's jld group under name  nm  #  ModelerToolbox.write_jld!  \u2014  Method .  write_jld! ( x ,   nm ,   obj )   Write the object  obj   x 's jld group under name  nm . This routine will overwrite any existing object with name  nm  in the group.  #  ModelerToolbox.read_jld  \u2014  Method .  read_jld ( x ,   nm )   Read the object with  nm  from   x 's jld group  #  ModelerToolbox.delete_jld!  \u2014  Method .  delete_jld! ( x ,   dataset )   Delete the object with name  dataset  from  x 's jld group  #  ModelerToolbox.haskey_jld  \u2014  Method .  haskey_jld ( x ,   dataset )   Check if the jld group for  x  has an object named  dataset  #  ModelerToolbox.names_jld  \u2014  Method .  names_jld ( x )   List all the names in  x 's jld group  #  ModelerToolbox.groups  \u2014  Method .  groups ( x )   Return the dict mapping keys to jld group names for all objects of type  typeof(x) . If the dict doesn't yet exist, it is created, along with a group for the instance  x .",
            "title": "JLD tools"
        }
    ]
}